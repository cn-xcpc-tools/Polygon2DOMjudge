from __future__ import annotations

import logging
import shutil
from typing import TYPE_CHECKING

from p2d.utils import ensure_dir, get_normalized_lang

if TYPE_CHECKING:
    from pathlib import Path

    from p2d.models import Result
    from p2d.pipeline import ProcessingContext

logger = logging.getLogger(__name__)

RESULT_REMAP = {
    "ACCEPTED": "CORRECT",
    "WRONG_ANSWER": "WRONG-ANSWER",
    "TIME_LIMIT_EXCEEDED": "TIMELIMIT",
    "RUN_TIME_ERROR": "RUN-ERROR",
    "COMPILER_ERROR": "COMPILER-ERROR",
    "NO_OUTPUT": "NO-OUTPUT",
    "OUTPUT_LIMIT": "OUTPUT-LIMIT",
}
"""Mapping from internal result names to DOMjudge @EXPECTED_RESULTS@ format."""


def _colorize_result(result: str) -> str:
    """Return a Rich-formatted string for the result verdict."""
    if result == "accepted":
        return f"[green italic]{result}[/]"
    if result == "wrong_answer":
        return f"[red italic]{result}[/]"
    return f"[yellow italic]{result}[/]"


def add_jury_solutions(ctx: ProcessingContext) -> None:
    """Copy jury solutions grouped by expected verdicts."""
    logger.info("[bold green reverse]Add jury solutions:[/]", extra={"markup": True})

    for solution in ctx.problem.solutions:
        tag = solution.attrib["tag"]
        results = ctx.config.tag.get(tag, None)

        if results is None:
            relative_dir = "rejected"
        elif len(results) == 1:
            relative_dir = results[0]
        else:
            relative_dir = "mixed"

        target_dir = ctx.temp_dir / "submissions" / relative_dir

        if (source := solution.find("source[@path][@type]")) is not None:
            ensure_dir(target_dir)
            src = ctx.package_dir / source.attrib["path"]
            dst = target_dir / src.name
            lang = source.attrib["type"]
            _add_solutions_with_expected_result(ctx, src, dst, lang, results)


def _add_solutions_with_expected_result(
    ctx: ProcessingContext,
    src: Path,
    dst: Path,
    lang: str,
    results: list[Result] | None,
) -> None:
    """Copy a solution file, adding @EXPECTED_RESULTS@ annotation if needed."""
    if results is None:
        logger.warning(
            "Find expected result with check_manually, you may add @EXPECTED_RESULTS@ in your source code for validation.",
        )
        shutil.copyfile(src, dst)
        return

    if len(results) == 1:
        logger.info("> %s: %s", src.name, _colorize_result(results[0]), extra={"markup": True})
        shutil.copyfile(src, dst)
        return

    content = src.read_text()

    if "@EXPECTED_RESULTS@" in content or "@EXPECTED_SCORE@" in content:
        logger.warning(
            "Find @EXPECTED_RESULTS@ or @EXPECTED_SCORE@ in %s, skip adding expected result.",
            src.name,
        )
        shutil.copyfile(src, dst)
        return

    logger.info(
        "> %s: %s",
        src.name,
        ", ".join(map(_colorize_result, results)),
        extra={"markup": True},
    )

    normalized_lang = get_normalized_lang(lang)
    if comment_str := ctx.config.comment_str.get(normalized_lang, None):
        remapped = ", ".join(RESULT_REMAP.get(res.upper(), res.upper()) for res in results)
        generated_comment = f"""
{comment_str} AUTO GENERATED BY POLYGON2DOMJUDGE
{comment_str} @EXPECTED_RESULTS@: {remapped}
"""
    else:
        logger.warning(
            "comment_str not found for type %s, skip adding expected result.",
            normalized_lang,
        )
        generated_comment = ""
    dst.write_text(content + generated_comment, encoding="utf-8")
